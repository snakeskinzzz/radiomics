print(paste('训练集样本数:',length(trainOmics[,1])))
print(paste('测试集样本数:',length(testOmics[,1])))
write.csv(trainOmics,"csv/trainOmics.csv",row.names = FALSE )
write.csv(testOmics,"csv/testOmics.csv",row.names = FALSE )
reticulate::repl_python()
tData_train <- read.csv("csv/tData_train.csv",fileEncoding = "UTF-8-BOM")
dim(tData_train)
Y <-as.data.frame(tData_train$label)
#[,-1]是为了去掉截距
Y <- model.matrix(~.,data=Y)[,-1]
#除去因变量，提取自变量
yavars<-names(tData_train) %in% c("label","index")
X <- as.data.frame(tData_train[!yavars])
X <- model.matrix(~.,data=X)[,-1]
#Lasso回归
fit <- glmnet(X,Y, alpha=1, family = "binomial")
plot(fit, xvar="lambda", label=TRUE)
cv.fit <- cv.glmnet(X,Y, alpha=1,nfolds = 10,family="binomial")
plot(cv.fit)
abline(v=log(c(cv.fit$lambda.min, cv.fit$lambda.lse)), lty=2)
plot(cv.fit$glmnet.fit,xvar="lambda")
abline(v=log(cv.fit$lambda.1se), lty=2,)
#如果取1倍标准误时,获取筛选后的特征
lambda = cv.fit$lambda.1se
Coefficients <- coef(fit, s = lambda)
Active.Index <- which(Coefficients != 0)
Active.Coefficients <- Coefficients[Active.Index]
Active.Index
Active.Coefficients
row.names(Coefficients)[Active.Index]
#如果取1倍标准误时,获取筛选后的特征
lambda = cv.fit$lambda.1se
Coefficients <- coef(fit, s = lambda)
Active.Index <- which(Coefficients != 0)
Active.Coefficients <- Coefficients[Active.Index]
Active.Index
Active.Coefficients
row.names(Coefficients)[Active.Index]
#如果取1倍标准误时,获取筛选后的特征
lambda = cv.fit$lambda.1se
Coefficients <- coef(fit, s = lambda)
Active.Index <- which(Coefficients != 0)
Active.Coefficients <- Coefficients[Active.Index]
Active.Index
Active.Coefficients
row.names(Coefficients)[Active.Index]
#如果取1倍标准误时,获取筛选后的特征
lambda = cv.fit$lambda.1se
Coefficients <- coef(fit, s = lambda)
Active.Index <- which(Coefficients != 0)
Active.Coefficients <- Coefficients[Active.Index]
Active.Index
Active.Coefficients
row.names(Coefficients)[Active.Index]
#如果取1倍标准误时,获取筛选后的特征
lambda = cv.fit$lambda.1se
Coefficients <- coef(fit, s = lambda)
Active.Index <- which(Coefficients != 0)
Active.Coefficients <- Coefficients[Active.Index]
Active.Index
Active.Coefficients
row.names(Coefficients)[Active.Index]
#如果取1倍标准误时,获取筛选后的特征
lambda = cv.fit$lambda.1se
Coefficients <- coef(fit, s = lambda)
Active.Index <- which(Coefficients != 0)
Active.Coefficients <- Coefficients[Active.Index]
Active.Index
Active.Coefficients
row.names(Coefficients)[Active.Index]
#如果取1倍标准误时,获取筛选后的特征
lambda = cv.fit$lambda.1se
Coefficients <- coef(fit, s = lambda)
Active.Index <- which(Coefficients != 0)
Active.Coefficients <- Coefficients[Active.Index]
Active.Index
Active.Coefficients
row.names(Coefficients)[Active.Index]
#如果取1倍标准误时,获取筛选后的特征
lambda = cv.fit$lambda.1se
Coefficients <- coef(fit, s = lambda)
Active.Index <- which(Coefficients != 0)
Active.Coefficients <- Coefficients[Active.Index]
Active.Index
Active.Coefficients
row.names(Coefficients)[Active.Index]
tData_train <- read.csv("csv/tData_train.csv",fileEncoding = "UTF-8-BOM")
dim(tData_train)
Y <-as.data.frame(tData_train$label)
#[,-1]是为了去掉截距
Y <- model.matrix(~.,data=Y)[,-1]
#除去因变量，提取自变量
yavars<-names(tData_train) %in% c("label","index")
X <- as.data.frame(tData_train[!yavars])
X <- model.matrix(~.,data=X)[,-1]
#Lasso回归
fit <- glmnet(X,Y, alpha=1, family = "binomial")
plot(fit, xvar="lambda", label=TRUE)
cv.fit <- cv.glmnet(X,Y, alpha=1,nfolds = 10,family="binomial")
plot(cv.fit)
abline(v=log(c(cv.fit$lambda.min, cv.fit$lambda.lse)), lty=2)
plot(cv.fit$glmnet.fit,xvar="lambda")
abline(v=log(cv.fit$lambda.1se), lty=2,)
#如果取1倍标准误时,获取筛选后的特征
lambda = cv.fit$lambda.1se
Coefficients <- coef(fit, s = lambda)
Active.Index <- which(Coefficients != 0)
Active.Coefficients <- Coefficients[Active.Index]
Active.Index
Active.Coefficients
row.names(Coefficients)[Active.Index]
formulalse <-as.formula(label ~original_shape_Maximum3DDiameter+original_shape_Sphericity+original_firstorder_Skewness+original_gldm_LargeDependenceHighGrayLevelEmphasis+wavelet.LHH_glcm_Imc2+wavelet.HLL_firstorder_Median+wavelet.HLL_glcm_InverseVariance+wavelet.LLL_firstorder_10Percentile)
model.Omics <- glm(formula=formulalse,data=tData_train,family=binomial(link="logit"))
#查查看结果
summary(model.Omics)
probOmicsTrain<-predict.glm(object =model.Omics,newdata=tData_train,type = "response")
predOmicsTrain<-ifelse(probOmicsTrain>=0.5,1,0)
error=predOmicsTrain-tData_train$label
accuracy=(nrow(tData_train)-sum(abs(error)))/nrow(tData_train)
precision=sum(tData_train$label & predOmicsTrain)/sum(predOmicsTrain)
recall=sum(predOmicsTrain & tData_train$label)/sum(tData_train$label)
F_measure=2*precision*recall/(precision+recall)
print(paste('准确率accuracy:',accuracy))
print(paste('精确率precision:',precision))
print(paste('召回率recall:',recall))
print(paste('F_measure:',F_measure))
table(tData_train$label,predOmicsTrain)
tData_test <- read.csv("csv/testOmics.csv",fileEncoding = "UTF-8-BOM")
probOmicsTest<-predict.glm(object =model.Omics,newdata=tData_test,type = "response")
predOmicsTest<-ifelse(probOmicsTest>=0.5,1,0)
error=predOmicsTest-tData_test$label
accuracy=(nrow(tData_test)-sum(abs(error)))/nrow(tData_test)
precision=sum(tData_test$label & predOmicsTest)/sum(predOmicsTest)
recall=sum(predOmicsTest & tData_test$label)/sum(tData_test$label)
F_measure=2*precision*recall/(precision+recall)
print(paste('准确率accuracy:',accuracy))
print(paste('精确率precision:',precision))
print(paste('召回率recall:',recall))
print(paste('F_measure:',F_measure))
table(tData_test$label,predOmicsTest)
rocOmics <- roc(tData_train$label, probOmicsTrain)
rocOmics
# 先绘制1条ROC曲线
plot(rocOmics,
print.auc=TRUE, # 图像上输出AUC的值
print.auc.x=0.4, print.auc.y=0.6, # 设置AUC值坐标为（x，y）
auc.polygon=TRUE, # 将ROC曲线下面积转化为多边形
auc.polygon.col="#fff7f7",  # 设置ROC曲线下填充色
grid=FALSE,
print.thres=FALSE, # 图像上输出最佳截断值
main=" Train ROC curves",  # 添加图形标题
col="red",    # 设置ROC曲线颜色
legacy.axes=TRUE,# 使x轴从0到1，表示为1-特异度
xlim=c(1,0),
mgp=c(1.5, 1, 0),
lty=3)
# 添加图例
legend(0.45, 0.30,  # 图例位置x，y
bty = "n",   # 图例样式
legend=c("Radiomics signature"),  # 添加分组
col=c("red","green","blue"),  # 颜色跟前面一致
lwd=1,
lty=c(3,2,1))  # 线条粗细
rocOmicsTest <- roc(tData_test$label, probOmicsTest)
rocOmicsTest
plot(rocOmicsTest,
print.auc=TRUE, # 图像上输出AUC的值
print.auc.x=0.4, print.auc.y=0.6, # 设置AUC值坐标为（x，y）
auc.polygon=TRUE, # 将ROC曲线下面积转化为多边形
auc.polygon.col="#fff7f7",  # 设置ROC曲线下填充色
grid=FALSE,
print.thres=FALSE, # 图像上输出最佳截断值
main=" Test ROC curves",  # 添加图形标题
col="red",    # 设置ROC曲线颜色
legacy.axes=TRUE,# 使x轴从0到1，表示为1-特异度
xlim=c(1,0),
mgp=c(1.5, 1, 0),
lty=3)
# 添加图例
legend(0.45, 0.30,  # 图例位置x，y
bty = "n",   # 图例样式
legend=c("Radiomics signature"),  # 添加分组
col=c("red","green","blue"),  # 颜色跟前面一致
lwd=1,
lty=c(3,2,1))  # 线条粗细
formulalse <-as.formula(label ~original_shape_Maximum3DDiameter+original_shape_Sphericity+original_firstorder_Skewness+wavelet.LHH_glcm_Imc2+wavelet.HLL_firstorder_Median+wavelet.HLL_glcm_InverseVariance+wavelet.LLL_firstorder_10Percentile)
formulalse <-as.formula(label ~original_shape_Maximum3DDiameter+original_shape_Sphericity+original_firstorder_Skewness+wavelet.LHH_glcm_Imc2+wavelet.HLL_firstorder_Median+wavelet.HLL_glcm_InverseVariance+wavelet.LLL_firstorder_10Percentile)
model.Omics <- glm(formula=formulalse,data=tData_train,family=binomial(link="logit"))
#查查看结果
summary(model.Omics)
probOmicsTrain<-predict.glm(object =model.Omics,newdata=tData_train,type = "response")
predOmicsTrain<-ifelse(probOmicsTrain>=0.5,1,0)
error=predOmicsTrain-tData_train$label
accuracy=(nrow(tData_train)-sum(abs(error)))/nrow(tData_train)
precision=sum(tData_train$label & predOmicsTrain)/sum(predOmicsTrain)
recall=sum(predOmicsTrain & tData_train$label)/sum(tData_train$label)
F_measure=2*precision*recall/(precision+recall)
print(paste('准确率accuracy:',accuracy))
print(paste('精确率precision:',precision))
print(paste('召回率recall:',recall))
print(paste('F_measure:',F_measure))
table(tData_train$label,predOmicsTrain)
tData_test <- read.csv("csv/testOmics.csv",fileEncoding = "UTF-8-BOM")
probOmicsTest<-predict.glm(object =model.Omics,newdata=tData_test,type = "response")
predOmicsTest<-ifelse(probOmicsTest>=0.5,1,0)
error=predOmicsTest-tData_test$label
accuracy=(nrow(tData_test)-sum(abs(error)))/nrow(tData_test)
precision=sum(tData_test$label & predOmicsTest)/sum(predOmicsTest)
recall=sum(predOmicsTest & tData_test$label)/sum(tData_test$label)
F_measure=2*precision*recall/(precision+recall)
print(paste('准确率accuracy:',accuracy))
print(paste('精确率precision:',precision))
print(paste('召回率recall:',recall))
print(paste('F_measure:',F_measure))
table(tData_test$label,predOmicsTest)
rocOmics <- roc(tData_train$label, probOmicsTrain)
rocOmics
# 先绘制1条ROC曲线
plot(rocOmics,
print.auc=TRUE, # 图像上输出AUC的值
print.auc.x=0.4, print.auc.y=0.6, # 设置AUC值坐标为（x，y）
auc.polygon=TRUE, # 将ROC曲线下面积转化为多边形
auc.polygon.col="#fff7f7",  # 设置ROC曲线下填充色
grid=FALSE,
print.thres=FALSE, # 图像上输出最佳截断值
main=" Train ROC curves",  # 添加图形标题
col="red",    # 设置ROC曲线颜色
legacy.axes=TRUE,# 使x轴从0到1，表示为1-特异度
xlim=c(1,0),
mgp=c(1.5, 1, 0),
lty=3)
# 添加图例
legend(0.45, 0.30,  # 图例位置x，y
bty = "n",   # 图例样式
legend=c("Radiomics signature"),  # 添加分组
col=c("red","green","blue"),  # 颜色跟前面一致
lwd=1,
lty=c(3,2,1))  # 线条粗细
rocOmicsTest <- roc(tData_test$label, probOmicsTest)
rocOmicsTest
plot(rocOmicsTest,
print.auc=TRUE, # 图像上输出AUC的值
print.auc.x=0.4, print.auc.y=0.6, # 设置AUC值坐标为（x，y）
auc.polygon=TRUE, # 将ROC曲线下面积转化为多边形
auc.polygon.col="#fff7f7",  # 设置ROC曲线下填充色
grid=FALSE,
print.thres=FALSE, # 图像上输出最佳截断值
main=" Test ROC curves",  # 添加图形标题
col="red",    # 设置ROC曲线颜色
legacy.axes=TRUE,# 使x轴从0到1，表示为1-特异度
xlim=c(1,0),
mgp=c(1.5, 1, 0),
lty=3)
# 添加图例
legend(0.45, 0.30,  # 图例位置x，y
bty = "n",   # 图例样式
legend=c("Radiomics signature"),  # 添加分组
col=c("red","green","blue"),  # 颜色跟前面一致
lwd=1,
lty=c(3,2,1))  # 线条粗细
options(reticulate.conda_binary = "/Users/headsnakeyu/Documents/anaconda3/condabin/conda")
library(reticulate)
use_condaenv("radio311", required = TRUE)
reticulate::repl_python()
#导入常用R包
library(glmnet)
library(rms)
library(foreign)
library(ggplot2)
library(pROC)
#设置种子为了保证每次结果都一样
set.seed(888)
data <- read.csv("csv/TotalOMICS.csv")
nn=0.7
print(paste('总样本数:',length(data[,1])))
sub<-sample(1:nrow(data),round(nrow(data)*nn))
trainOmics<-data[sub,]#取0.8的数据做训练集
testOmics<-data[-sub,]#取0.2的数据做测试集
print(paste('训练集样本数:',length(trainOmics[,1])))
print(paste('测试集样本数:',length(testOmics[,1])))
write.csv(trainOmics,"csv/trainOmics.csv",row.names = FALSE )
write.csv(testOmics,"csv/testOmics.csv",row.names = FALSE )
reticulate::repl_python()
tData_train <- read.csv("csv/tData_train.csv",fileEncoding = "UTF-8-BOM")
dim(tData_train)
Y <-as.data.frame(tData_train$label)
#[,-1]是为了去掉截距
Y <- model.matrix(~.,data=Y)[,-1]
#除去因变量，提取自变量
yavars<-names(tData_train) %in% c("label","index")
X <- as.data.frame(tData_train[!yavars])
X <- model.matrix(~.,data=X)[,-1]
#Lasso回归
fit <- glmnet(X,Y, alpha=1, family = "binomial")
plot(fit, xvar="lambda", label=TRUE)
cv.fit <- cv.glmnet(X,Y, alpha=1,nfolds = 10,family="binomial")
plot(cv.fit)
abline(v=log(c(cv.fit$lambda.min, cv.fit$lambda.lse)), lty=2)
plot(cv.fit$glmnet.fit,xvar="lambda")
abline(v=log(cv.fit$lambda.1se), lty=2,)
#如果取1倍标准误时,获取筛选后的特征
lambda = cv.fit$lambda.1se
Coefficients <- coef(fit, s = lambda)
Active.Index <- which(Coefficients != 0)
Active.Coefficients <- Coefficients[Active.Index]
Active.Index
Active.Coefficients
row.names(Coefficients)[Active.Index]
print("特征提取成功")
options(reticulate.conda_binary = "/Users/headsnakeyu/Documents/anaconda3/condabin/conda")
library(reticulate)
use_condaenv("radio311", required = TRUE)
reticulate::repl_python()
#导入常用R包
library(glmnet)
library(rms)
library(foreign)
library(ggplot2)
library(pROC)
#设置种子为了保证每次结果都一样
set.seed(888)
data <- read.csv("csv/TotalOMICS.csv")
nn=0.7
print(paste('总样本数:',length(data[,1])))
sub<-sample(1:nrow(data),round(nrow(data)*nn))
trainOmics<-data[sub,]#取0.8的数据做训练集
testOmics<-data[-sub,]#取0.2的数据做测试集
print(paste('训练集样本数:',length(trainOmics[,1])))
print(paste('测试集样本数:',length(testOmics[,1])))
write.csv(trainOmics,"csv/trainOmics.csv",row.names = FALSE )
write.csv(testOmics,"csv/testOmics.csv",row.names = FALSE )
reticulate::repl_python()
tData_train <- read.csv("csv/tData_train.csv",fileEncoding = "UTF-8-BOM")
dim(tData_train)
Y <-as.data.frame(tData_train$label)
#[,-1]是为了去掉截距
Y <- model.matrix(~.,data=Y)[,-1]
#除去因变量，提取自变量
yavars<-names(tData_train) %in% c("label","index")
X <- as.data.frame(tData_train[!yavars])
X <- model.matrix(~.,data=X)[,-1]
#Lasso回归
fit <- glmnet(X,Y, alpha=1, family = "binomial")
plot(fit, xvar="lambda", label=TRUE)
cv.fit <- cv.glmnet(X,Y, alpha=1,nfolds = 10,family="binomial")
plot(cv.fit)
abline(v=log(c(cv.fit$lambda.min, cv.fit$lambda.lse)), lty=2)
plot(cv.fit$glmnet.fit,xvar="lambda")
abline(v=log(cv.fit$lambda.1se), lty=2,)
#如果取1倍标准误时,获取筛选后的特征
lambda = cv.fit$lambda.1se
Coefficients <- coef(fit, s = lambda)
Active.Index <- which(Coefficients != 0)
Active.Coefficients <- Coefficients[Active.Index]
Active.Index
Active.Coefficients
row.names(Coefficients)[Active.Index]
print("特征提取成功")
#如果取1倍标准误时,获取筛选后的特征
lambda = cv.fit$lambda.1se
Coefficients <- coef(fit, s = lambda)
Active.Index <- which(Coefficients != 0)
Active.Coefficients <- Coefficients[Active.Index]
Active.Index
Active.Coefficients
row.names(Coefficients)[Active.Index]
print("特征提取成功")
formulalse <-as.formula(label ~original_firstorder_Kurtosis+original_shape_Sphericity+original_glcm_JointAverage+wavelet.LHH_glcm_Imc2+wavelet.HLL_glcm_Idm+wavelet.HLL_glcm_InverseVariance+wavelet.LLL_firstorder_10Percentile+wavelet.LLL_gldm_GrayLevelNonUniformity)
model.Omics <- glm(formula=formulalse,data=tData_train,family=binomial(link="logit"))
#查查看结果
summary(model.Omics)
probOmicsTrain<-predict.glm(object =model.Omics,newdata=tData_train,type = "response")
predOmicsTrain<-ifelse(probOmicsTrain>=0.5,1,0)
error=predOmicsTrain-tData_train$label
accuracy=(nrow(tData_train)-sum(abs(error)))/nrow(tData_train)
precision=sum(tData_train$label & predOmicsTrain)/sum(predOmicsTrain)
recall=sum(predOmicsTrain & tData_train$label)/sum(tData_train$label)
F_measure=2*precision*recall/(precision+recall)
print(paste('准确率accuracy:',accuracy))
print(paste('精确率precision:',precision))
print(paste('召回率recall:',recall))
print(paste('F_measure:',F_measure))
table(tData_train$label,predOmicsTrain)
tData_test <- read.csv("csv/testOmics.csv",fileEncoding = "UTF-8-BOM")
probOmicsTest<-predict.glm(object =model.Omics,newdata=tData_test,type = "response")
predOmicsTest<-ifelse(probOmicsTest>=0.5,1,0)
error=predOmicsTest-tData_test$label
accuracy=(nrow(tData_test)-sum(abs(error)))/nrow(tData_test)
precision=sum(tData_test$label & predOmicsTest)/sum(predOmicsTest)
recall=sum(predOmicsTest & tData_test$label)/sum(tData_test$label)
F_measure=2*precision*recall/(precision+recall)
print(paste('准确率accuracy:',accuracy))
print(paste('精确率precision:',precision))
print(paste('召回率recall:',recall))
print(paste('F_measure:',F_measure))
table(tData_test$label,predOmicsTest)
rocOmics <- roc(tData_train$label, probOmicsTrain)
rocOmics
# 先绘制1条ROC曲线
plot(rocOmics,
print.auc=TRUE, # 图像上输出AUC的值
print.auc.x=0.4, print.auc.y=0.6, # 设置AUC值坐标为（x，y）
auc.polygon=TRUE, # 将ROC曲线下面积转化为多边形
auc.polygon.col="#fff7f7",  # 设置ROC曲线下填充色
grid=FALSE,
print.thres=FALSE, # 图像上输出最佳截断值
main=" Train ROC curves",  # 添加图形标题
col="red",    # 设置ROC曲线颜色
legacy.axes=TRUE,# 使x轴从0到1，表示为1-特异度
xlim=c(1,0),
mgp=c(1.5, 1, 0),
lty=3)
# 添加图例
legend(0.45, 0.30,  # 图例位置x，y
bty = "n",   # 图例样式
legend=c("Radiomics signature"),  # 添加分组
col=c("red","green","blue"),  # 颜色跟前面一致
lwd=1,
lty=c(3,2,1))  # 线条粗细
rocOmicsTest <- roc(tData_test$label, probOmicsTest)
rocOmicsTest
plot(rocOmicsTest,
print.auc=TRUE, # 图像上输出AUC的值
print.auc.x=0.4, print.auc.y=0.6, # 设置AUC值坐标为（x，y）
auc.polygon=TRUE, # 将ROC曲线下面积转化为多边形
auc.polygon.col="#fff7f7",  # 设置ROC曲线下填充色
grid=FALSE,
print.thres=FALSE, # 图像上输出最佳截断值
main=" Test ROC curves",  # 添加图形标题
col="red",    # 设置ROC曲线颜色
legacy.axes=TRUE,# 使x轴从0到1，表示为1-特异度
xlim=c(1,0),
mgp=c(1.5, 1, 0),
lty=3)
# 添加图例
legend(0.45, 0.30,  # 图例位置x，y
bty = "n",   # 图例样式
legend=c("Radiomics signature"),  # 添加分组
col=c("red","green","blue"),  # 颜色跟前面一致
lwd=1,
lty=c(3,2,1))  # 线条粗细
print("finish")
plot(rocOmicsTest,
print.auc=TRUE, # 图像上输出AUC的值
print.auc.x=0.4, print.auc.y=0.6, # 设置AUC值坐标为（x，y）
auc.polygon=TRUE, # 将ROC曲线下面积转化为多边形
auc.polygon.col="#fff7f7",  # 设置ROC曲线下填充色
grid=FALSE,
print.thres=FALSE, # 图像上输出最佳截断值
main=" Test ROC curves",  # 添加图形标题
col="red",    # 设置ROC曲线颜色
legacy.axes=TRUE,# 使x轴从0到1，表示为1-特异度
xlim=c(1,0),
mgp=c(1.5, 1, 0),
lty=3)
# 添加图例
legend(0.45, 0.30,  # 图例位置x，y
bty = "n",   # 图例样式
legend=c("Radiomics signature"),  # 添加分组
col=c("red","green","blue"),  # 颜色跟前面一致
lwd=1,
lty=c(3,2,1))  # 线条粗细
print("finish")
options(reticulate.conda_binary = "/Users/headsnakeyu/Documents/anaconda3/condabin/conda")
library(reticulate)
use_condaenv("radio311", required = TRUE)
reticulate::repl_python()
#导入常用R包
library(glmnet)
library(rms)
library(foreign)
library(ggplot2)
library(pROC)
#设置种子为了保证每次结果都一样
set.seed(888)
data <- read.csv("csv/TotalOMICS.csv")
nn=0.7
print(paste('总样本数:',length(data[,1])))
sub<-sample(1:nrow(data),round(nrow(data)*nn))
trainOmics<-data[sub,]#取0.8的数据做训练集
testOmics<-data[-sub,]#取0.2的数据做测试集
print(paste('训练集样本数:',length(trainOmics[,1])))
print(paste('测试集样本数:',length(testOmics[,1])))
write.csv(trainOmics,"csv/trainOmics.csv",row.names = FALSE )
write.csv(testOmics,"csv/testOmics.csv",row.names = FALSE )
reticulate::repl_python()
tData_train <- read.csv("csv/tData_train.csv",fileEncoding = "UTF-8-BOM")
dim(tData_train)
Y <-as.data.frame(tData_train$label)
#[,-1]是为了去掉截距
Y <- model.matrix(~.,data=Y)[,-1]
#除去因变量，提取自变量
yavars<-names(tData_train) %in% c("label","index")
X <- as.data.frame(tData_train[!yavars])
X <- model.matrix(~.,data=X)[,-1]
#Lasso回归
fit <- glmnet(X,Y, alpha=1, family = "binomial")
plot(fit, xvar="lambda", label=TRUE)
cv.fit <- cv.glmnet(X,Y, alpha=1,nfolds = 10,family="binomial")
plot(cv.fit)
abline(v=log(c(cv.fit$lambda.min, cv.fit$lambda.lse)), lty=2)
plot(cv.fit$glmnet.fit,xvar="lambda")
abline(v=log(cv.fit$lambda.1se), lty=2,)
#如果取1倍标准误时,获取筛选后的特征
lambda = cv.fit$lambda.1se
Coefficients <- coef(fit, s = lambda)
Active.Index <- which(Coefficients != 0)
Active.Coefficients <- Coefficients[Active.Index]
Active.Index
Active.Coefficients
row.names(Coefficients)[Active.Index]
print("特征提取成功")
